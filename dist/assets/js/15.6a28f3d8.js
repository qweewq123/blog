(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{312:function(e,t,r){e.exports=r.p+"assets/img/lifecycle.eebd1208.jpg"},321:function(e,t,r){"use strict";r.r(t);var a=[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"vue生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期","aria-hidden":"true"}},[e._v("#")]),e._v(" vue生命周期")]),a("p",[e._v("vue提供很多钩子。比较常见的有生命周期钩子，生命周期是vue执行的关键。")]),a("h2",{attrs:{id:"生命周期图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期图","aria-hidden":"true"}},[e._v("#")]),e._v(" 生命周期图")]),a("p",[a("img",{attrs:{src:r(312),alt:"image"}})]),a("h2",{attrs:{id:"生命周期的解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期的解析","aria-hidden":"true"}},[e._v("#")]),e._v(" 生命周期的解析")]),a("p",[e._v("beforeCreate 和 created 的 $el 是undefined，所以 "),a("strong",[e._v("beforeCreate")]),e._v(" 和 "),a("strong",[e._v("created")]),e._v(" 阶段是不能进行dom操作的，因为拿不到 dom 节点。")]),a("p",[e._v("brforeMount 时，$el变成了我们写在 html 中 div 节点。")]),a("p",[e._v("mounted 时， $el变成了 template 中的html，说明覆盖了html原来的 div 节点。")]),a("p",[e._v("mounted之后，我们调用的所有生命周期方法，拿到的节点，都是渲染之后的节点。")]),a("ul",[a("li",[a("p",[e._v("ajax请求最好放在created里面，因为此时已经可以访问this了，请求到数据就可以直接放在data里面。")])]),a("li",[a("p",[e._v("关于dom的操作要放在mounted里面，在mounted前面访问dom会是undefined。")])]),a("li",[a("p",[e._v("每次进入/离开组件都要做一些事情，用什么钩子：")])]),a("li",[a("p",[e._v("不缓存：")]),a("p",[e._v("进入的时候可以用created和mounted钩子，离开的时候用beforeDestory和destroyed钩子,beforeDestory可以访问this，destroyed不可以访问this。")])]),a("li",[a("p",[e._v("缓存了组件：")]),a("p",[e._v("缓存了组件之后，再次进入组件不会触发beforeCreate、created 、beforeMount、 mounted，如果你想每次进入组件都做一些事情的话，你可以放在activated进入缓存组件的钩子中。\n同理：离开缓存组件的时候，beforeDestroy和destroyed并不会触发，可以使用deactivated离开缓存组件的钩子来代替。")])])])])}],d=r(1),s=Object(d.a)({},function(){this.$createElement;this._self._c;return this._m(0)},a,!1,null,null,null);t.default=s.exports}}]);